import fc from 'fast-check';
import { AuthService } from '../auth.service';
import { UserModel } from '../../models';
import { generateToken, verifyToken } from '../../utils/jwt';
import { pool } from '../../config/database';

/**
 * Property-Based Tests for JWT Authentication
 * Feature: job-trackr
 */

describe('JWT Authentication - Property-Based Tests', () => {
  // Clean up test data after each test
  afterEach(async () => {
    await pool.query('DELETE FROM users WHERE email LIKE $1', ['%@jwt-pbt-test.com']);
  });

  afterAll(async () => {
    // Clean up - don't close the pool as other tests may need it
  });

  /**
   * Property 3: Valid login returns JWT token
   * **Validates: Requirements 1.3**
   * 
   * For any registered user, logging in with correct credentials should return
   * a valid JWT token that can be used for authentication.
   */
  test(
    'Property 3: Valid login returns JWT token',
    async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate valid email addresses
          fc.record({
            localPart: fc.stringMatching(/^[a-z0-9]{1,20}$/),
            domain: fc.constantFrom('jwt-pbt-test.com'),
          }).map(({ localPart, domain }) => `${localPart}@${domain}`),
          // Generate valid passwords (minimum 8 characters)
          fc.string({ minLength: 8, maxLength: 50 }),
          async (email, password) => {
            // Register a user first
            const registerResponse = await AuthService.register({ email, password });
            expect(registerResponse).toBeDefined();
            expect(registerResponse.token).toBeDefined();

            // Login with the same credentials
            const loginResponse = await AuthService.login({ email, password });

            // Verify login returns a token
            expect(loginResponse).toBeDefined();
            expect(loginResponse.token).toBeDefined();
            expect(typeof loginResponse.token).toBe('string');
            expect(loginResponse.token.length).toBeGreaterThan(0);

            // Verify the token is a valid JWT (has 3 parts separated by dots)
            const tokenParts = loginResponse.token.split('.');
            expect(tokenParts).toHaveLength(3);

            // Verify the token can be decoded and contains correct user information
            const decoded = verifyToken(loginResponse.token);
            expect(decoded).toBeDefined();
            expect(decoded.userId).toBe(registerResponse.user.id);
            expect(decoded.email).toBe(email);
            expect(decoded.role).toBe('user');

            // Verify user information is returned without password hash
            expect(loginResponse.user).toBeDefined();
            expect(loginResponse.user.id).toBe(registerResponse.user.id);
            expect(loginResponse.user.email).toBe(email);
            expect(loginResponse.user.role).toBe('user');
            expect((loginResponse.user as any).passwordHash).toBeUndefined();

            // Clean up
            await UserModel.delete(registerResponse.user.id);
          }
        ),
        { numRuns: 100 }
      );
    },
    60000 // 60 second timeout for property-based test with 100 runs
  );

  /**
   * Property 5: Valid JWT token authenticates user
   * **Validates: Requirements 1.5**
   * 
   * For any valid JWT token generated by the system, using it in API requests
   * should successfully authenticate the user.
   */
  test(
    'Property 5: Valid JWT token authenticates user',
    async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate valid email addresses
          fc.record({
            localPart: fc.stringMatching(/^[a-z0-9]{1,20}$/),
            domain: fc.constantFrom('jwt-pbt-test.com'),
          }).map(({ localPart, domain }) => `${localPart}@${domain}`),
          // Generate valid passwords
          fc.string({ minLength: 8, maxLength: 50 }),
          // Generate role
          fc.constantFrom('user' as const, 'admin' as const),
          async (email, password, role) => {
            // Create a user directly with specified role
            const user = await UserModel.create(email, password, role);
            expect(user).toBeDefined();

            // Generate a JWT token for the user
            const token = generateToken(user);
            expect(token).toBeDefined();
            expect(typeof token).toBe('string');

            // Verify the token can be successfully verified
            const decoded = verifyToken(token);
            expect(decoded).toBeDefined();

            // Verify decoded token contains correct user information
            expect(decoded.userId).toBe(user.id);
            expect(decoded.email).toBe(email);
            expect(decoded.role).toBe(role);

            // Verify we can retrieve the user from the database using the decoded userId
            const retrievedUser = await UserModel.findById(decoded.userId);
            expect(retrievedUser).not.toBeNull();
            expect(retrievedUser?.id).toBe(user.id);
            expect(retrievedUser?.email).toBe(email);
            expect(retrievedUser?.role).toBe(role);

            // Clean up
            await UserModel.delete(user.id);
          }
        ),
        { numRuns: 100 }
      );
    },
    60000 // 60 second timeout
  );

  /**
   * Property 6: Invalid JWT token rejected
   * **Validates: Requirements 1.6**
   * 
   * For any expired, malformed, or invalid JWT token, the system should reject
   * authentication and return an error.
   */
  test(
    'Property 6: Invalid JWT token rejected',
    async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate various types of invalid tokens
          fc.oneof(
            // Malformed tokens (not proper JWT format)
            fc.string({ minLength: 1, maxLength: 100 }).filter(s => !s.includes('.')),
            // Tokens with wrong number of parts
            fc.string({ minLength: 1, maxLength: 50 }).map(s => `${s}.${s}`),
            fc.string({ minLength: 1, maxLength: 30 }).map(s => `${s}.${s}.${s}.${s}`),
            // Random base64-like strings with correct structure but invalid signature
            fc.tuple(
              fc.stringMatching(/^[A-Za-z0-9_-]{10,50}$/),
              fc.stringMatching(/^[A-Za-z0-9_-]{10,50}$/),
              fc.stringMatching(/^[A-Za-z0-9_-]{10,50}$/)
            ).map(([header, payload, signature]) => `${header}.${payload}.${signature}`),
            // Empty or whitespace tokens
            fc.constantFrom('', '   ', '\t', '\n')
          ),
          async (invalidToken) => {
            // Attempt to verify the invalid token should throw an error
            expect(() => verifyToken(invalidToken)).toThrow();

            // Try-catch to verify specific error messages
            try {
              verifyToken(invalidToken);
              // If we reach here, the test should fail
              fail('Expected verifyToken to throw an error for invalid token');
            } catch (error) {
              // Verify error is thrown and has a message
              expect(error).toBeDefined();
              expect(error instanceof Error).toBe(true);
              if (error instanceof Error) {
                expect(error.message).toBeDefined();
                expect(error.message.length).toBeGreaterThan(0);
              }
            }
          }
        ),
        { numRuns: 100 }
      );
    },
    30000 // 30 second timeout
  );

  /**
   * Additional test: Expired JWT tokens are rejected
   * This is part of Property 6 but specifically tests token expiration
   */
  test(
    'Property 6 (Expired): Expired JWT tokens are rejected',
    async () => {
      // Create a user
      const email = 'expired-test@jwt-pbt-test.com';
      const password = 'testpassword123';
      const user = await UserModel.create(email, password);

      // Generate a token with very short expiration (1 second)
      const jwt = require('jsonwebtoken');
      const JWT_SECRET = process.env.JWT_SECRET || 'default-secret-key';
      const expiredToken = jwt.sign(
        {
          userId: user.id,
          email: user.email,
          role: user.role,
        },
        JWT_SECRET,
        { expiresIn: '1s' }
      );

      // Wait for token to expire
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Attempt to verify the expired token should throw an error
      expect(() => verifyToken(expiredToken)).toThrow();

      try {
        verifyToken(expiredToken);
        fail('Expected verifyToken to throw an error for expired token');
      } catch (error) {
        expect(error).toBeDefined();
        expect(error instanceof Error).toBe(true);
        if (error instanceof Error) {
          expect(error.message).toContain('expired');
        }
      }

      // Clean up
      await UserModel.delete(user.id);
    },
    10000 // 10 second timeout
  );

  /**
   * Additional test: Invalid credentials are rejected during login
   * This validates Property 4 (Requirements 1.4) as part of the JWT authentication flow
   */
  test(
    'Property 4: Invalid credentials rejected',
    async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate valid email addresses
          fc.record({
            localPart: fc.stringMatching(/^[a-z0-9]{1,20}$/),
            domain: fc.constantFrom('jwt-pbt-test.com'),
          }).map(({ localPart, domain }) => `${localPart}@${domain}`),
          // Generate two different passwords
          fc.string({ minLength: 8, maxLength: 50 }),
          fc.string({ minLength: 8, maxLength: 50 }).filter(p => p.length >= 8),
          async (email, correctPassword, wrongPassword) => {
            // Skip if passwords happen to be the same
            if (correctPassword === wrongPassword) {
              return;
            }

            // Register a user
            const registerResponse = await AuthService.register({ email, password: correctPassword });
            expect(registerResponse).toBeDefined();

            // Attempt to login with wrong password should throw an error
            await expect(
              AuthService.login({ email, password: wrongPassword })
            ).rejects.toThrow('Invalid credentials');

            // Attempt to login with non-existent email should throw an error
            await expect(
              AuthService.login({ email: 'nonexistent@jwt-pbt-test.com', password: correctPassword })
            ).rejects.toThrow('Invalid credentials');

            // Clean up
            await UserModel.delete(registerResponse.user.id);
          }
        ),
        { numRuns: 100 }
      );
    },
    60000 // 60 second timeout
  );
});
